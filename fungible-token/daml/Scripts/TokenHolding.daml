module Scripts.TokenHolding where

import Prelude hiding (forA)

import DA.Action (when, unless, void, foldlA)
import DA.Assert
import DA.Exception
import DA.Foldable (forA_)
import DA.List (dedupSort)
import DA.Map (Map)
import qualified DA.Map as Map
import DA.Optional (fromOptional, optionalToList)
import DA.Set (Set)
import qualified DA.Set as Set
import qualified DA.TextMap as TextMap
import DA.Traversable (forA)
import qualified DA.Text as T
import DA.Time
import Daml.Script

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.TransferInstructionV1

import Fungible.TokenHolding

balanceOf: Party -> InstrumentId -> Script Decimal
balanceOf p instrumentId = do
  holdings <- listHoldings p instrumentId
  pure $ sum $ map (._2.amount) holdings

listHoldings: Party -> InstrumentId -> Script [(ContractId Holding, HoldingView)]
listHoldings p instrumentId = do
  holdings <- queryInterface @Holding p
  let instrumentHoldings = do
      (cid, Some holding) <- holdings
      guard (holding.instrumentId == instrumentId)
      guard (holding.owner == p)
      pure (cid, holding)
  pure instrumentHoldings

listHoldingCids: Party -> InstrumentId -> Script [ContractId Holding]
listHoldingCids p instrumentId = (map fst) <$> listHoldings p instrumentId

listTransferOffers: Party -> InstrumentId -> Script [(ContractId TransferInstruction, TransferInstructionView)]
listTransferOffers p instrumentId = do
  ixs <- queryInterface @TransferInstruction p
  let pendingOffers = do
      (cid, Some instr) <- ixs
      guard (instr.transfer.instrumentId == instrumentId)
      guard (instr.status == TransferPendingReceiverAcceptance)
      guard (p == instr.transfer.sender || p == instr.transfer.receiver)
      pure (cid, instr)
  pure pendingOffers