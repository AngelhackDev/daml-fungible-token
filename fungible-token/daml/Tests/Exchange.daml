module Tests.Exchange where

import Prelude hiding (forA)
import DA.Optional (fromSome)
import qualified DA.TextMap as TextMap
import Daml.Script

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.TransferInstructionV1
import Splice.Api.Token.HoldingV1

import Tests.Holding
import Tests.Utils
import Fungible.TokenTransferFactory
import Fungible.TokenHolding
import Exchange.ExchangeInstruction qualified as ExchangeInstruction (ExchangeInstruction(..), Match(..))

exchange: Script HoldingState
exchange = do
  HoldingState
    { bank
    ; alice
    ; bob
    ; charlie
    ; ccInstrumentId
    ; usdtInstrumentId
    ; aliceHoldings
    ; bobHoldings
    ; charlieHoldings
    } <- setupHolding
  
  tokenTransferFactoryCid <- submit bank $ createCmd TokenTransferFactory with admin = bank; meta = emptyMetadata
  let transferFactoryCid = coerceContractId tokenTransferFactoryCid

  -- Alice wants to exchange 100 CC for 50 USDT
  exchangeIxCid <- submit alice do
    createCmd ExchangeInstruction.ExchangeInstruction with
      transferFactoryCid
      transferFactoryAdmin = bank
      maker = alice
      offeredInstrumentId = ccInstrumentId
      offeredAmount = 100.0
      offeredHoldings = map fst aliceHoldings
      desiredInstrumentId = usdtInstrumentId
      desiredAmount = 50.0

  -- Bob partially matches this exchange
  disclosedIx <- fromSome <$> queryDisclosure @ExchangeInstruction.ExchangeInstruction alice exchangeIxCid
  disclosedTransferFactory <- fromSome <$> queryDisclosure @TokenTransferFactory bank tokenTransferFactoryCid
  disclosedAliceCids <- fromSomes <$> queryDisclosures @TokenHolding alice (map (coerceContractId . fst) aliceHoldings)
  (aliceToBobIx, bobToAliceIx, Some remainingExchangeCid) <- submitWithDisclosures bob ([disclosedIx, disclosedTransferFactory] <> disclosedAliceCids) do
    exerciseCmd exchangeIxCid ExchangeInstruction.Match with
      taker = bob
      matchOfferedAmount = 25.0
      desiredHoldings = map fst bobHoldings
  submitMulti [bob, alice, bank] [] do
    exerciseCmd aliceToBobIx TransferInstruction_Accept with
      extraArgs = ExtraArgs with
        context = ChoiceContext with values = TextMap.empty
        meta = emptyMetadata
  submitMulti [bob, alice, bank] [] do
    exerciseCmd bobToAliceIx TransferInstruction_Accept with
      extraArgs = ExtraArgs with
        context = ChoiceContext with values = TextMap.empty
        meta = emptyMetadata

  -- Charlie fully matches the remaining
  disclosedIx <- fromSome <$> queryDisclosure @ExchangeInstruction.ExchangeInstruction alice remainingExchangeCid
  Some remainingExchangeIx <- queryContractId alice remainingExchangeCid
  disclosedRemainingHoldingCid <- fromSomes <$> queryDisclosures @TokenHolding alice (map coerceContractId remainingExchangeIx.offeredHoldings)
  (aliceToCharlieIx, charlieToAliceIx, _) <- submitWithDisclosures charlie ([disclosedIx, disclosedTransferFactory] <> disclosedRemainingHoldingCid) do
    exerciseCmd remainingExchangeCid ExchangeInstruction.Match with
      taker = charlie
      matchOfferedAmount = 75.0
      desiredHoldings = map fst charlieHoldings
  submitMulti [charlie, alice, bank] [] do
    exerciseCmd aliceToCharlieIx TransferInstruction_Accept with
      extraArgs = ExtraArgs with
        context = ChoiceContext with values = TextMap.empty
        meta = emptyMetadata
  submitMulti [charlie, alice, bank] [] do
    exerciseCmd charlieToAliceIx TransferInstruction_Accept with
      extraArgs = ExtraArgs with
        context = ChoiceContext with values = TextMap.empty
        meta = emptyMetadata

  pure (HoldingState bank alice bob charlie ccInstrumentId usdtInstrumentId aliceHoldings bobHoldings charlieHoldings)