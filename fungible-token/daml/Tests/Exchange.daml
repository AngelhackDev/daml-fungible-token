module Tests.Exchange where

import Prelude hiding (forA)

import DA.Action (when, unless, void, foldlA)
import DA.Assert
import DA.Exception
import DA.Foldable (forA_)
import DA.List (dedupSort)
import DA.Map (Map)
import qualified DA.Map as Map
import DA.Optional (fromOptional, optionalToList, fromSome)
import DA.Set (Set)
import qualified DA.Set as Set
import qualified DA.TextMap as TextMap
import DA.Traversable (forA)
import qualified DA.Text as T
import DA.Time
import Daml.Script

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.TransferInstructionV1

import Fungible.TokenHolding
import Fungible.TokenMint qualified as TokenMint (TokenMintRequest(..), AcceptMint(..))
import Scripts.TokenHolding qualified as TokenHoldingScripts (listHoldings, balanceOf)
import Tests.Utils
import Tests.Holding
import Fungible.TokenTransferFactory
import Fungible.TokenTransferInstruction
import Exchange.ExchangeInstruction qualified as ExchangeInstruction (ExchangeInstruction(..), Match(..))

exchange: Script HoldingState
exchange = do
  HoldingState
    { bank
    ; alice
    ; bob
    ; charlie
    ; ccInstrumentId
    ; usdtInstrumentId
    ; aliceHoldings
    ; bobHoldings
    ; charlieHoldings
    } <- setupHolding
  
  tokenTransferFactoryCid <- submit bank $ createCmd TokenTransferFactory with admin = bank; meta = emptyMetadata
  let transferFactoryCid = coerceContractId tokenTransferFactoryCid

  -- Alice wants to exchange 100 CC for 50 USDT
  exchangeIxCid <- submit alice do
    createCmd ExchangeInstruction.ExchangeInstruction with
      transferFactoryCid
      transferFactoryAdmin = bank
      maker = alice
      offeredInstrumentId = ccInstrumentId
      offeredAmount = 100.0
      offeredHoldings = map fst aliceHoldings
      desiredInstrumentId = usdtInstrumentId
      desiredAmount = 50.0

  -- Bob partially matches this exchange
  disclosedIx <- fromSome <$> queryDisclosure @ExchangeInstruction.ExchangeInstruction alice exchangeIxCid
  disclosedTransferFactory <- fromSome <$> queryDisclosure @TokenTransferFactory bank tokenTransferFactoryCid
  (aliceToBobIx, bobToAliceIx, optExchangeIxCid) <- submitWithDisclosures bob [disclosedIx, disclosedTransferFactory] do
    exerciseCmd exchangeIxCid ExchangeInstruction.Match with
      taker = bob
      matchOfferedAmount = 25.0
      desiredHoldings = map fst bobHoldings
  submitMulti [bob, alice, bank] [] do
    exerciseCmd aliceToBobIx TransferInstruction_Accept with
      extraArgs = ExtraArgs with
        context = ChoiceContext with values = TextMap.empty
        meta = emptyMetadata
  submitMulti [bob, alice, bank] [] do
    exerciseCmd bobToAliceIx TransferInstruction_Accept with
      extraArgs = ExtraArgs with
        context = ChoiceContext with values = TextMap.empty
        meta = emptyMetadata

  -- Extract the remaining exchange contract ID
  let remainingExchangeCid = case optExchangeIxCid of
        Some cid -> cid
        None -> error "Expected a remaining exchange contract ID after partial match"

  -- Charlie fully matches the remaining
  disclosedIx <- fromSome <$> queryDisclosure @ExchangeInstruction.ExchangeInstruction alice remainingExchangeCid
  (aliceToCharlieIx, charlieToAliceIx, optExchangeIxCid) <- submitWithDisclosures charlie [disclosedIx, disclosedTransferFactory] do
    exerciseCmd remainingExchangeCid ExchangeInstruction.Match with
      taker = charlie
      matchOfferedAmount = 75.0
      desiredHoldings = map fst charlieHoldings
  -- submitMulti [charlie, alice, bank] [] do
  --   exerciseCmd aliceToCharlieIx TransferInstruction_Accept with
  --     extraArgs = ExtraArgs with
  --       context = ChoiceContext with values = TextMap.empty
  --       meta = emptyMetadata
  -- submitMulti [charlie, alice, bank] [] do
  --   exerciseCmd charlieToAliceIx TransferInstruction_Accept with
  --     extraArgs = ExtraArgs with
  --       context = ChoiceContext with values = TextMap.empty
  --       meta = emptyMetadata

  pure (HoldingState bank alice bob charlie ccInstrumentId usdtInstrumentId aliceHoldings bobHoldings charlieHoldings)