-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Exchange.ExchangeInstruction where

import Prelude hiding (forA)

import DA.Action (when, unless, void, foldlA)
import DA.Assert
import DA.Exception
import DA.Foldable (forA_)
import DA.List (dedupSort)
import DA.Map (Map)
import qualified DA.Map as Map
import DA.Optional (fromOptional, optionalToList)
import DA.Set (Set)
import qualified DA.Set as Set
import qualified DA.TextMap as TextMap
import DA.Traversable (forA)
import qualified DA.Text as T
import DA.Time
import Daml.Script

import Splice.Api.Token.MetadataV1 qualified as MetadataV1 (emptyMetadata)
import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.TransferInstructionV1 qualified as TransferInstructionV1 (Transfer(..), TransferFactory(..), TransferFactory_Transfer(..), TransferInstruction(..), TransferInstructionResult(..), TransferInstructionResult_Output(..))

import Fungible.TokenHolding
import qualified DA.Map as Map
import qualified DA.TextMap as TextMap
import Fungible.TokenTransferFactory

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1

template ExchangeInstruction
  with
    transferFactoryCid: ContractId TransferInstructionV1.TransferFactory
    transferFactoryAdmin: Party
    maker: Party
    offeredInstrumentId: InstrumentId
    offeredAmount: Decimal
    offeredHoldings: [ContractId Holding]
    desiredInstrumentId: InstrumentId
    desiredAmount: Decimal
  where
    signatory maker
    ensure offeredAmount > 0.0 && desiredAmount > 0.0

    choice Match: (ContractId TransferInstructionV1.TransferInstruction, ContractId TransferInstructionV1.TransferInstruction, Optional (ContractId ExchangeInstruction))
      with
        taker: Party
        matchOfferedAmount: Decimal
        desiredHoldings: [ContractId Holding]
      controller taker
      do
        assertMsg "Invalid match offered amount" (matchOfferedAmount > 0.0 && matchOfferedAmount <= offeredAmount)
        let matchDesiredAmount = desiredAmount * (matchOfferedAmount / offeredAmount)
        now <- getTime

        -- 1. Transfer offered tokens from maker to taker
        makerToTakerResult <- exercise transferFactoryCid TransferInstructionV1.TransferFactory_Transfer with
          expectedAdmin = transferFactoryAdmin
          transfer = TransferInstructionV1.Transfer with
            sender = maker
            receiver = taker
            amount = matchOfferedAmount
            instrumentId = offeredInstrumentId
            requestedAt = now
            executeBefore = now `addRelTime` days 1
            inputHoldingCids = offeredHoldings
            meta = MetadataV1.emptyMetadata
          extraArgs = ExtraArgs with
            context = ChoiceContext with values = TextMap.empty
            meta = MetadataV1.emptyMetadata
        let makerToTakerIx = case makerToTakerResult.output of
              TransferInstructionV1.TransferInstructionResult_Pending {transferInstructionCid, ..} -> transferInstructionCid
              TransferInstructionV1.TransferInstructionResult_Completed _ -> error "unexpected completed result"
              TransferInstructionV1.TransferInstructionResult_Failed -> error "unexpected failed result"

        -- 2. Transfer desired tokens from taker to maker
        takerToMakerResult <- exercise transferFactoryCid TransferInstructionV1.TransferFactory_Transfer with
          expectedAdmin = transferFactoryAdmin
          transfer = TransferInstructionV1.Transfer with
            sender = taker
            receiver = maker
            amount = matchDesiredAmount
            instrumentId = desiredInstrumentId
            requestedAt = now
            executeBefore = now `addRelTime` days 1
            inputHoldingCids = desiredHoldings
            meta = MetadataV1.emptyMetadata
          extraArgs = ExtraArgs with
            context = ChoiceContext with values = TextMap.empty
            meta = MetadataV1.emptyMetadata
        let takerToMakerIx = case takerToMakerResult.output of
              TransferInstructionV1.TransferInstructionResult_Pending {transferInstructionCid, ..} -> transferInstructionCid
              TransferInstructionV1.TransferInstructionResult_Completed _ -> error "unexpected completed result"
              TransferInstructionV1.TransferInstructionResult_Failed -> error "unexpected failed result"

        if matchOfferedAmount < offeredAmount then do
          cid <- create ExchangeInstruction with
            transferFactoryCid
            transferFactoryAdmin
            maker
            offeredInstrumentId
            offeredAmount = offeredAmount - matchOfferedAmount
            desiredInstrumentId
            desiredAmount = desiredAmount - matchDesiredAmount
            offeredHoldings = makerToTakerResult.senderChangeCids
          return (makerToTakerIx, takerToMakerIx, Some cid)
        else
          return (makerToTakerIx, takerToMakerIx, None)